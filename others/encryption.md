> 常用的加密算法，并非密码学理论

# 1. 编码算法

## 1.1. 编码

[跳转](../base/encoding.md)

## 1.2. URL 编码

- 作用：兼容非ASCII字符
  - URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分，例如：

    ```url
    https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87
    ```
  - 之所以需要URL编码，是因为出于兼容性考虑，
    - 很多服务器只识别ASCII字符。
    - 但如果URL中包含中文、日文这些非ASCII字符，就需要进行url编码

- url编码规则：
  - 如果字符是`A~Z`，`a~z`，`0~9`以及`-`、`_`、`.`、`*`，则保持不变；
  - 如果是其他字符，先转换为UTF-8编码，然后对每个字节以%XX表示。
  - 例如：字符中的UTF-8编码是0xe4b8ad，因此，它的URL编码是%E4%B8%AD。URL编码总是大写。

## 1.3. Base64 编码

### 1.3.1. 说明

- 作用：
  - 对二进制数据进行编码，表示成文本格式。
  - 但会降低传输效率，把原始数据的长度增加了1/3。

    ```
    如果把Base64的64个字符编码表换成32个、48个或者58个，
    就可以使用Base32编码，Base48编码和Base58编码。
    字符越少，编码的效率就会越低。
    ```

- 编码规则：
  - Base64编码可以把任意长度的二进制数据变为纯文本，
  - 且只包含`A~Z`、`a~z`、`0~9`、`+`、`/`、`=`这些字符。
  - 原理：
    - 把 **3字节(24bit)的二进制数据按6bit一组，用4个int整数表示**
    - 然后查表，把int整数用索引对应到字符，得到编码后的字符串。
    - 不是字节数不是3的整数时：
      - 待编码的输入刚好是24 bits，没有“=”填充。
      - 待编码的输入刚好是8 bits，首先用0填充使6 bits完整的一组，在填充2个“=”符号，最后刚好是24 bits。
      - 待编码的输入刚好是16 bits，首先用0填充使6 bits完整的一组，在填充1个“=”符号，最后刚好是24bits。
  - 编码表
    - 因为6位整数的范围总是0~63，所以，能用64个字符表示：
    - 字符A~Z对应索引0~25，
    - 字符a~z对应索引26~51，
    - 字符0~9对应索引52~61，
    - 最后两个索引62、63分别用字符+和/表示。

- 示例：

  ```
  ┌───────────────┬───────────────┬───────────────┐
  │      e4       │      b8       │      ad       │
  └───────────────┴───────────────┴───────────────┘
  ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐─┬─┬─┬─┬─┬─
  │1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│1│0│
  └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘─┴─┴─┴─┴─┴─
  ┌───────────┬───────────┬───────────┬───────────┐
  │    39     │    0b     │    22     │    2d     │
  └───────────┴───────────┴───────────┴───────────┘
        5          L            i          t

  ```

- 针对URL的64位编码：
  - 因为标准的Base64编码会出现+、/和=，所以不适合把Base64编码后的字符串放到URL中。
  - 一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是 **把+变成-，/变成_**

# 2. 哈希(hash)算法/摘要(digest)算法

## 2.1. 说明

- 哈希算法（Hash）又称摘要算法（Digest）
  - 它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。
  - 哈希算法最重要的特点就是：
    - 相同的输入一定得到相同的输出；
    - 不同的输入大概率得到不同的输出。
  - 哈希算法的目的就是为了验证原始数据是否被篡改

- 哈希碰撞: 两个不同的输入得到了相同的输出

- 因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：
  - 碰撞概率低；
  - 不能猜测输出。
    - 输入的任意一个bit的变化会造成输出完全不同，这样就很难从输出反推输入（只能依靠暴力穷举）

```
> 维基百科

- 算法特性
  - 正向计算hash很容易
  - 反向破解hash极其困难
  - hash值碰撞概率极小
```

## 2.2. 彩虹表与salt

## 2.3. 常见算法

| 算法       | 输出长度（位） | 输出长度（字节） |
| :--------- | :------------- | :--------------- |
| MD5        | 128 bits       | 16 bytes         |
| SHA-1      | 160 bits       | 20 bytes         |
| RipeMD-160 | 160 bits       | 20 bytes         |
| SHA-256    | 256 bits       | 32 bytes         |
| SHA-512    | 512 bits       | 64 bytes         |

## 2.4. 高级hash算法：

### 2.4.1. murmurhash

### 2.4.2. cityhash

## 2.5. java 库-BouncyCastle

## 2.6. 变种

### 2.6.1. hashids

> [github 源码](https://github.com/davidaurelio/hashids-python)

- hashids满足第1和第3条
  - 正向计算hash很快
  - **hash值完全没有碰撞** ，保证了唯一性。
- hash值长度不固定，可指定最短长度。随着id增长，hash值会越来越长
- 如果知道salt值，还可以逆向通过hash值计算出原值。
  - 那第2条是否满足取决于你的salt秘钥有多容易被攻击者拿到。
  - 如果你的salt秘钥来自于常用字典单词，那攻击者可以通过彩虹字典快速将秘钥破解。

# 3. Hmac 算法

> ak/sk

# 4. 对称加密算法

## 4.1. 算法说明

| 算法 | 密钥长度    | 工作模式             | 填充模式                                |
| :--- | :---------- | :------------------- | :-------------------------------------- |
| DES  | 56/64       | ECB/CBC/PCBC/CTR/... | NoPadding/PKCS5Padding/...              |
| AES  | 128/192/256 | ECB/CBC/PCBC/CTR/... | NoPadding/PKCS5Padding/PKCS7Padding/... |
| IDEA | 128         | ECB                  | PKCS5Padding/PKCS7Padding/...           |

## 4.2. 示例

# 5. 口令加密算法

## 5.1. 说明

## 5.2. 示例

# 6. 密钥交换算法

## 6.1. 说明

## 6.2. 实现

# 7. 非对称加密算法

# 8. 签名算法

# 9. 数字证书

- Https 的连接与中间人攻击

# 10. uuid算法

## 10.1. uuid各版本

> 版本 1/2 适用于需要高度唯一性且无需重复的场景；
> 版本 3/5 适用于一定范围内唯一且需要或可能会重复生成UUID的环境下；
> 版本 4 适用于对唯一性要求不太严格且追求简单的场景。

### 10.1.1. 基于时间

### 10.1.2. 分布式安全

### 10.1.3. 基于namespace(MD5)

### 10.1.4. 基于随机数

### 10.1.5. 基于namespace(SHA1)

## 10.2. GUID

- GUID有两种解释：
  - 就是UUID
  - 特指微软对UUID标准的实现

# 11. 参考资料

<!-- TODO: 加密算法。有时间继续整理一下吧 -->

- [关于加密、证书的那些事](https://www.cnblogs.com/sewain/p/14250884.html)
- [廖雪峰-加密与安全](https://www.liaoxuefeng.com/wiki/1252599548343744/1255943717668160)
- [hashids库说明](https://zhuanlan.zhihu.com/p/32671455)
  - [Cryptanalysis of hashids](http://carnage.github.io/2015/08/cryptanalysis-of-hashids)
- [HTTPS 证书和中间人攻击的原理](https://cloud.tencent.com/developer/article/1900287)
- [LEB128编码格式](http://gttiankai.github.io/2016/06/30/leb128%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/)
